package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"text/template"
	"time"
)

// Estructuras para parsear seeds JSON
type PermissionSeed struct {
	Bit         int    `json:"bit"`
	Key         string `json:"key"`
	Label       string `json:"label"`
	Description string `json:"description"`
}

type PermissionGroup struct {
	Key         string   `json:"key"`
	Label       string   `json:"label"`
	Description string   `json:"description"`
	Permissions []string `json:"permissions"`
}

type PermissionFile struct {
	Scope        string            `json:"scope"`
	SinceVersion int               `json:"since_version"`
	Permissions  []PermissionSeed  `json:"permissions"`
	Groups       []PermissionGroup `json:"groups"`
}

type RoleDef struct {
	Label       string   `json:"label"`
	Description string   `json:"description"`
	Groups      []string `json:"groups"`
}

type RoleFile struct {
	Scope string             `json:"scope"`
	Roles map[string]RoleDef `json:"roles"`
}

func main() {
	seedsDir := flag.String("seeds", "../../Connect-Auth/seeds", "Path to Connect-Auth seeds directory")
	outputDir := flag.String("output", ".", "Output directory for generated files")
	flag.Parse()

	fmt.Println("üîß Connect-Internal Code Generator")
	fmt.Println("===================================")

	// Generar permisos
	if err := generatePermissions(*seedsDir, *outputDir); err != nil {
		fmt.Fprintf(os.Stderr, "‚ùå Error generating permissions: %v\n", err)
		os.Exit(1)
	}

	// Generar roles
	if err := generateRoles(*seedsDir, *outputDir); err != nil {
		fmt.Fprintf(os.Stderr, "‚ùå Error generating roles: %v\n", err)
		os.Exit(1)
	}

	fmt.Println("‚úÖ Code generation completed successfully!")
}

func generatePermissions(seedsDir, outputDir string) error {
	fmt.Println("\nüìã Generating permissions...")

	permDir := filepath.Join(seedsDir, "permissions")
	outDir := filepath.Join(outputDir, "permissions")

	if err := os.MkdirAll(outDir, 0755); err != nil {
		return fmt.Errorf("create output dir: %w", err)
	}

	// Leer todos los archivos JSON
	files, err := filepath.Glob(filepath.Join(permDir, "*.json"))
	if err != nil {
		return fmt.Errorf("glob permissions: %w", err)
	}

	for _, file := range files {
		scope := strings.TrimSuffix(filepath.Base(file), ".json")
		fmt.Printf("  - Processing %s.json...\n", scope)

		data, err := os.ReadFile(file)
		if err != nil {
			return fmt.Errorf("read %s: %w", file, err)
		}

		var permFile PermissionFile
		if err := json.Unmarshal(data, &permFile); err != nil {
			return fmt.Errorf("parse %s: %w", file, err)
		}

		// Generar archivo Go
		outFile := filepath.Join(outDir, scope+".go")
		if err := generatePermissionFile(outFile, &permFile); err != nil {
			return fmt.Errorf("generate %s: %w", outFile, err)
		}

		fmt.Printf("    ‚úì Generated %s (%d permissions, %d groups)\n",
			outFile, len(permFile.Permissions), len(permFile.Groups))
	}

	// Generar permissions.go con helpers comunes
	helpersFile := filepath.Join(outDir, "permissions.go")
	if err := generatePermissionHelpers(helpersFile); err != nil {
		return fmt.Errorf("generate helpers: %w", err)
	}
	fmt.Printf("    ‚úì Generated %s (helpers)\n", helpersFile)

	return nil
}

func generatePermissionFile(outFile string, perm *PermissionFile) error {
	// Ordenar permisos por bit
	sort.Slice(perm.Permissions, func(i, j int) bool {
		return perm.Permissions[i].Bit < perm.Permissions[j].Bit
	})

	tmpl := `// Code generated by tools/generate.go - DO NOT EDIT
// Source: Connect-Auth/seeds/permissions/{{ .Scope | lower }}.json
// Generated: {{ .Timestamp }}

package permissions

// {{ .Scope }} Scope Permissions ({{ .PermCount }} permissions)
// Use with authz.Can(ctx, userID, scopeID, scopeType, permissionBit)
const (
{{- range .Permissions }}
	{{ .ConstName }} = {{ .Bit }} // {{ .Label }}: {{ .Description }}
{{- end }}
)

// {{ .Scope }} Permission Groups
// Groups are used by roles to assign multiple permissions at once
var (
{{- range .Groups }}
	{{ .VarName }} = []int{
{{- range .PermBits }}
		{{ . }},
{{- end }}
	} // {{ .Label }}: {{ .Description }}
{{- end }}
)

// {{ .Scope }}PermissionInfo provides metadata for all {{ .Scope }} permissions
var {{ .Scope }}PermissionInfo = map[int]PermissionInfo{
{{- range .Permissions }}
	{{ .ConstName }}: {
		Bit:         {{ .Bit }},
		Key:         "{{ .Key }}",
		Label:       "{{ .Label }}",
		Description: "{{ .Description }}",
		Scope:       "{{ $.Scope }}",
	},
{{- end }}
}

// Get{{ .Scope }}PermissionKey returns the permission key string for a bit
func Get{{ .Scope }}PermissionKey(bit int) string {
	if info, ok := {{ .Scope }}PermissionInfo[bit]; ok {
		return info.Key
	}
	return ""
}

// Get{{ .Scope }}PermissionBit returns the bit number for a permission key
func Get{{ .Scope }}PermissionBit(key string) (int, bool) {
	for bit, info := range {{ .Scope }}PermissionInfo {
		if info.Key == key {
			return bit, true
		}
	}
	return -1, false
}
`

	// Preparar datos para template
	data := struct {
		Scope       string
		Timestamp   string
		PermCount   int
		Permissions []struct {
			ConstName   string
			Bit         int
			Key         string
			Label       string
			Description string
		}
		Groups []struct {
			VarName     string
			Label       string
			Description string
			PermBits    []string
		}
	}{
		Scope:     perm.Scope,
		Timestamp: time.Now().Format("2006-01-02 15:04:05"),
		PermCount: len(perm.Permissions),
	}

	// Convertir permisos
	for _, p := range perm.Permissions {
		data.Permissions = append(data.Permissions, struct {
			ConstName   string
			Bit         int
			Key         string
			Label       string
			Description string
		}{
			ConstName:   p.Key, // Ya viene en formato correcto
			Bit:         p.Bit,
			Key:         p.Key,
			Label:       p.Label,
			Description: p.Description,
		})
	}

	// Convertir grupos
	permKeyToBit := make(map[string]int)
	for _, p := range perm.Permissions {
		permKeyToBit[p.Key] = p.Bit
	}

	for _, g := range perm.Groups {
		varName := g.Key // Ya viene en formato correcto (ej: WEB__BASIC)
		var permBits []string
		for _, permKey := range g.Permissions {
			permBits = append(permBits, permKey)
		}

		data.Groups = append(data.Groups, struct {
			VarName     string
			Label       string
			Description string
			PermBits    []string
		}{
			VarName:     varName,
			Label:       g.Label,
			Description: g.Description,
			PermBits:    permBits,
		})
	}

	// Ejecutar template
	t := template.Must(template.New("permissions").Funcs(template.FuncMap{
		"lower": strings.ToLower,
	}).Parse(tmpl))

	f, err := os.Create(outFile)
	if err != nil {
		return err
	}
	defer f.Close()

	return t.Execute(f, data)
}

func generatePermissionHelpers(outFile string) error {
	content := `// Code generated by tools/generate.go - DO NOT EDIT

package permissions

// PermissionInfo holds metadata about a permission
type PermissionInfo struct {
	Bit         int
	Key         string
	Label       string
	Description string
	Scope       string
}

// GetPermissionKey returns the permission key for any scope
func GetPermissionKey(scope string, bit int) string {
	switch scope {
	case "WEB":
		return GetWEBPermissionKey(bit)
	case "TEAM":
		return GetTEAMPermissionKey(bit)
	case "LOBBY":
		return GetLOBBYPermissionKey(bit)
	case "COMMUNITY":
		return GetCOMMUNITYPermissionKey(bit)
	default:
		return ""
	}
}

// GetPermissionBit returns the bit number for any scope's permission key
func GetPermissionBit(scope, key string) (int, bool) {
	switch scope {
	case "WEB":
		return GetWEBPermissionBit(key)
	case "TEAM":
		return GetTEAMPermissionBit(key)
	case "LOBBY":
		return GetLOBBYPermissionBit(key)
	case "COMMUNITY":
		return GetCOMMUNITYPermissionBit(key)
	default:
		return -1, false
	}
}
`

	return os.WriteFile(outFile, []byte(content), 0644)
}

func generateRoles(seedsDir, outputDir string) error {
	fmt.Println("\nüé≠ Generating roles...")

	roleDir := filepath.Join(seedsDir, "roles")
	outDir := filepath.Join(outputDir, "roles")

	if err := os.MkdirAll(outDir, 0755); err != nil {
		return fmt.Errorf("create output dir: %w", err)
	}

	// Leer todos los archivos JSON
	files, err := filepath.Glob(filepath.Join(roleDir, "*.json"))
	if err != nil {
		return fmt.Errorf("glob roles: %w", err)
	}

	for _, file := range files {
		scope := strings.TrimSuffix(filepath.Base(file), ".json")
		fmt.Printf("  - Processing %s.json...\n", scope)

		data, err := os.ReadFile(file)
		if err != nil {
			return fmt.Errorf("read %s: %w", file, err)
		}

		var roleFile RoleFile
		if err := json.Unmarshal(data, &roleFile); err != nil {
			return fmt.Errorf("parse %s: %w", file, err)
		}

		// Generar archivo Go
		outFile := filepath.Join(outDir, scope+".go")
		if err := generateRoleFile(outFile, &roleFile); err != nil {
			return fmt.Errorf("generate %s: %w", outFile, err)
		}

		fmt.Printf("    ‚úì Generated %s (%d roles)\n", outFile, len(roleFile.Roles))
	}

	// Generar roles.go con helpers comunes
	helpersFile := filepath.Join(outDir, "roles.go")
	if err := generateRoleHelpers(helpersFile); err != nil {
		return fmt.Errorf("generate helpers: %w", err)
	}
	fmt.Printf("    ‚úì Generated %s (helpers)\n", helpersFile)

	return nil
}

func generateRoleFile(outFile string, role *RoleFile) error {
	tmpl := `// Code generated by tools/generate.go - DO NOT EDIT
// Source: Connect-Auth/seeds/roles/{{ .Scope | lower }}.json
// Generated: {{ .Timestamp }}

package roles

// {{ .Scope }} Scope Role Constants
const (
{{- range .RoleConsts }}
	{{ .ConstName }} = "{{ .RoleKey }}" // {{ .Label }}
{{- end }}
)

// {{ .Scope }} Role Definitions
var (
{{- range .Roles }}
	{{ .VarName }} = Role{
		Scope:       "{{ $.Scope }}",
		Name:        {{ .ConstRef }},
		Label:       "{{ .Label }}",
		Description: "{{ .Description }}",
		Groups:      []string{ {{ .GroupsList }} },
	}
{{- end }}
)

// Get{{ .Scope }}Role returns a role definition by name
func Get{{ .Scope }}Role(name string) (Role, bool) {
	switch name {
{{- range .Roles }}
	case {{ .ConstRef }}:
		return {{ .VarName }}, true
{{- end }}
	default:
		return Role{}, false
	}
}

// Get{{ .Scope }}Roles returns all {{ .Scope }} roles
func Get{{ .Scope }}Roles() []Role {
	return []Role{
{{- range .Roles }}
		{{ .VarName }},
{{- end }}
	}
}
`

	// Preparar datos para template
	data := struct {
		Scope      string
		Timestamp  string
		RoleConsts []struct {
			ConstName string
			RoleKey   string
			Label     string
		}
		Roles []struct {
			VarName     string
			ConstRef    string
			Label       string
			Description string
			GroupsList  string
		}
	}{
		Scope:     role.Scope,
		Timestamp: time.Now().Format("2006-01-02 15:04:05"),
	}

	// Generar constantes y variables
	for roleName, roleDef := range role.Roles {
		// Constante de nombre
		constName := strings.ToUpper(role.Scope) + "_" + strings.ToUpper(strings.ReplaceAll(roleName, "_", "_"))
		if strings.HasPrefix(constName, strings.ToUpper(role.Scope)+"_"+strings.ToUpper(role.Scope)) {
			// Evitar duplicaci√≥n como WEB_WEB_USER ‚Üí WEB_USER
			constName = strings.ToUpper(role.Scope) + "_" + strings.ToUpper(strings.TrimPrefix(roleName, strings.ToLower(role.Scope)+"_"))
		}

		data.RoleConsts = append(data.RoleConsts, struct {
			ConstName string
			RoleKey   string
			Label     string
		}{
			ConstName: constName,
			RoleKey:   roleName,
			Label:     roleDef.Label,
		})

		// Variable de definici√≥n
		varName := role.Scope + strings.ReplaceAll(toCamelCase(roleName), role.Scope, "")
		groupsList := ""
		if len(roleDef.Groups) > 0 {
			quoted := make([]string, len(roleDef.Groups))
			for i, g := range roleDef.Groups {
				quoted[i] = fmt.Sprintf(`"%s"`, g)
			}
			groupsList = strings.Join(quoted, ", ")
		}

		data.Roles = append(data.Roles, struct {
			VarName     string
			ConstRef    string
			Label       string
			Description string
			GroupsList  string
		}{
			VarName:     varName,
			ConstRef:    constName,
			Label:       roleDef.Label,
			Description: roleDef.Description,
			GroupsList:  groupsList,
		})
	}

	// Ejecutar template
	t := template.Must(template.New("roles").Funcs(template.FuncMap{
		"lower": strings.ToLower,
	}).Parse(tmpl))

	f, err := os.Create(outFile)
	if err != nil {
		return err
	}
	defer f.Close()

	return t.Execute(f, data)
}

func generateRoleHelpers(outFile string) error {
	content := `// Code generated by tools/generate.go - DO NOT EDIT

package roles

// Role defines a role with its associated permission groups
type Role struct {
	Scope       string
	Name        string
	Label       string
	Description string
	Groups      []string // Permission group keys
}

// HasRole checks if a role name exists in a list of roles
func HasRole(roleName string, userRoles []string) bool {
	for _, r := range userRoles {
		if r == roleName {
			return true
		}
	}
	return false
}

// GetRole returns a role definition by scope and name
func GetRole(scope, name string) (Role, bool) {
	switch scope {
	case "WEB":
		return GetWEBRole(name)
	case "TEAM":
		return GetTEAMRole(name)
	case "LOBBY":
		return GetLOBBYRole(name)
	case "COMMUNITY":
		return GetCOMMUNITYRole(name)
	default:
		return Role{}, false
	}
}

// GetAllRoles returns all roles for a scope
func GetAllRoles(scope string) []Role {
	switch scope {
	case "WEB":
		return GetWEBRoles()
	case "TEAM":
		return GetTEAMRoles()
	case "LOBBY":
		return GetLOBBYRoles()
	case "COMMUNITY":
		return GetCOMMUNITYRoles()
	default:
		return []Role{}
	}
}
`

	return os.WriteFile(outFile, []byte(content), 0644)
}

func toCamelCase(s string) string {
	parts := strings.Split(s, "_")
	for i := range parts {
		if len(parts[i]) > 0 {
			parts[i] = strings.ToUpper(parts[i][:1]) + strings.ToLower(parts[i][1:])
		}
	}
	return strings.Join(parts, "")
}
